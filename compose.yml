# Docker compose file for running the app and migrations for development environment.
# Db migrations are run in a separate container.


services:
  app:
    build:
      context: .
    restart: always
    container_name: app
    environment:
      - ASPNETCORE_ENVIRONMENT=${ASPNETCORE_ENVIRONMENT:-Development}
      - ASPNETCORE_HTTPS_PORT=https://+:${ASPNETCORE_HTTPS_PORT:-8443}
      - ASPNETCORE_URLS=http://+:${ASPNETCORE_HTTP_PORTS:-8000}
      #- ConnectionStrings__DefaultConnection=Data Source=/var/tmp/mydb.db
    volumes:
      - ./docker/healthchecks:/healthchecks
    healthcheck:
      test: /healthchecks/curl.sh
      interval: 10s
      timeout: 3s
      retries: 10
      start_period: 10s
    ports:
      - 8000:8000
      - 8443:8443
    depends_on:
      migrations:
        condition: service_completed_successfully

  # Run migrations:
  migrations:
    build: ./docker/migrations
    container_name: migrations
    tty: true
    restart: no
    environment:
      - ASPNETCORE_ENVIRONMENT=${ASPNETCORE_ENVIRONMENT:-Development}
      #- ConnectionStrings__DefaultConnection=Data Source=/var/tmp/mydb.db
    ## Required to mount the app code and run migrations
    volumes:
      - $PWD/src:/app:rw
      ## Optional: example of mounting appsettings.json and run migrations:
      #- $PWD/src/appsettings.json:/app/appsettings.json:ro
      #- $PWD/src/Migrations:/app/Migrations:rw
    entrypoint:
      - /bin/bash
      - -c
      - |
        set -exo pipefail
        dotnet ef database update --context ApplicationDbContext --verbose
        dotnet ef migrations list --no-build --context ApplicationDbContext --verbose
